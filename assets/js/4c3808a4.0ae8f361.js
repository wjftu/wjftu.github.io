"use strict";(self.webpackChunkwjftu_ds=self.webpackChunkwjftu_ds||[]).push([[5586],{3898:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"algorithmPractice/leetcode/146","title":"146 LRU Cache","description":"Leetcode","source":"@site/note/algorithmPractice/leetcode/146.md","sourceDirName":"algorithmPractice/leetcode","slug":"/algorithmPractice/leetcode/146","permalink":"/note/algorithmPractice/leetcode/146","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":146,"frontMatter":{"sidebar_position":146},"sidebar":"tutorialSidebar","previous":{"title":"142 Linked List Cycle II","permalink":"/note/algorithmPractice/leetcode/142"},"next":{"title":"152 Maximum Product Subarray","permalink":"/note/algorithmPractice/leetcode/152"}}');var i=t(4848),o=t(8453);const c={sidebar_position:146},r="146 LRU Cache",s={},l=[];function d(e){const n={a:"a",br:"br",code:"code",h1:"h1",header:"header",hr:"hr",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"146-lru-cache",children:"146 LRU Cache"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/lru-cache/",children:"Leetcode"})}),"\n",(0,i.jsx)(n.p,{children:"Design a data structure that follows the constraints of a Least Recently Used (LRU) cache."}),"\n",(0,i.jsx)(n.p,{children:"Implement the LRUCache class:"}),"\n",(0,i.jsxs)(n.p,{children:["LRUCache(int capacity) Initialize the LRU cache with positive size capacity.",(0,i.jsx)(n.br,{}),"\n","int get(int key) Return the value of the key if the key exists, otherwise return -1.",(0,i.jsx)(n.br,{}),"\n","void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.",(0,i.jsx)(n.br,{}),"\n","The functions get and put must each run in O(1) average time complexity."]}),"\n",(0,i.jsx)(n.p,{children:"Example 1:"}),"\n",(0,i.jsxs)(n.p,{children:["Input",(0,i.jsx)(n.br,{}),"\n",'["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]',(0,i.jsx)(n.br,{}),"\n","[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",(0,i.jsx)(n.br,{}),"\n","Output",(0,i.jsx)(n.br,{}),"\n","[null, null, null, 1, null, -1, null, -1, 3, 4]"]}),"\n",(0,i.jsx)(n.p,{children:"Explanation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"LRUCache lRUCache = new LRUCache(2);  \nlRUCache.put(1, 1); // cache is {1=1}  \nlRUCache.put(2, 2); // cache is {1=1, 2=2}  \nlRUCache.get(1);    // return 1  \nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}  \nlRUCache.get(2);    // returns -1 (not found)  \nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}  \nlRUCache.get(1);    // return -1 (not found)  \nlRUCache.get(3);    // return 3  \nlRUCache.get(4);    // return 4  \n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"\u4f7f\u7528\u94fe\u8868\u548c hash \u8868\uff0c\u8fbe\u5230\u67e5\u627e\u65f6\u95f4\u590d\u6742\u5ea6 o(1) \uff0c\u589e\u52a0\u548c\u66f4\u65b0\u7f13\u5b58\u65f6\u95f4\u590d\u6742\u5ea6 o(1)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"class LRUCache {\n\n    Node head, tail;\n    HashMap<Integer, Node> map;\n    int capacity, size;\n\n    public LRUCache(int capacity) {\n        head=new Node(0,0);\n        tail=new Node(0,0);\n        head.next=tail;\n        tail.pre=head;\n        map=new HashMap<>();\n        this.capacity=capacity;\n        this.size=0;\n    }\n\n    public int get(int key) {\n        Node node = map.get(key);\n        if(node==null){\n            return -1;\n        }\n        node.pre.next=node.next;\n        node.next.pre=node.pre;\n        insertNextTo(node, head);\n        return node.val;\n    }\n\n    public void put(int key, int value) {\n        Node node = map.get(key);\n        if(node!=null){\n            node.val=value;\n            node.pre.next=node.next;\n            node.next.pre=node.pre;\n            insertNextTo(node, head);\n            return;\n        }\n\n        if(size<capacity){\n            node = new Node(key,value);\n            map.put(key, node);\n            size++;\n            insertNextTo(node, head);\n        } else {\n            node = tail.pre;\n            map.remove(node.key);\n            node.key = key;\n            node.val = value;\n            tail.pre=node.pre;\n            node.pre.next=tail;\n            insertNextTo(node, head);\n            map.put(key, node);\n        }\n    }\n\n\n    private void insertNextTo(Node node, Node nextTo){\n        nextTo.next.pre=node;\n        node.next=nextTo.next;\n        node.pre=nextTo;\n        nextTo.next=node;\n    }\n\n    private class Node{\n        int key,val;\n        Node pre,next;\n        public Node(int key, int val){\n            this.key=key;\n            this.val=val;\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>r});var a=t(6540);const i={},o=a.createContext(i);function c(e){const n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);