"use strict";(self.webpackChunkwjftu_ds=self.webpackChunkwjftu_ds||[]).push([[3817],{8453:(n,e,t)=>{t.d(e,{R:()=>c,x:()=>o});var i=t(6540);const r={},s=i.createContext(r);function c(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:c(n.components),i.createElement(s.Provider,{value:e},n.children)}},9108:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>c,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"algorithmPractice/leetcode/76","title":"76 Minimum Window Substring","description":"Leetcode","source":"@site/note/algorithmPractice/leetcode/76.md","sourceDirName":"algorithmPractice/leetcode","slug":"/algorithmPractice/leetcode/76","permalink":"/note/algorithmPractice/leetcode/76","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":76,"frontMatter":{"sidebar_position":76},"sidebar":"tutorialSidebar","previous":{"title":"74 Search a 2D Matrix","permalink":"/note/algorithmPractice/leetcode/74"},"next":{"title":"78 Subsets","permalink":"/note/algorithmPractice/leetcode/78"}}');var r=t(4848),s=t(8453);const c={sidebar_position:76},o="76 Minimum Window Substring",a={},l=[];function d(n){const e={a:"a",br:"br",code:"code",h1:"h1",header:"header",hr:"hr",p:"p",pre:"pre",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"76-minimum-window-substring",children:"76 Minimum Window Substring"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://leetcode.com/problems/minimum-window-substring/",children:"Leetcode"})}),"\n",(0,r.jsx)(e.p,{children:'Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string "".'}),"\n",(0,r.jsx)(e.p,{children:"The testcases will be generated such that the answer is unique."}),"\n",(0,r.jsx)(e.p,{children:"A substring is a contiguous sequence of characters within the string."}),"\n",(0,r.jsx)(e.p,{children:"Example 1:"}),"\n",(0,r.jsxs)(e.p,{children:['Input: s = "ADOBECODEBANC", t = "ABC"',(0,r.jsx)(e.br,{}),"\n",'Output: "BANC"',(0,r.jsx)(e.br,{}),"\n","Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t."]}),"\n",(0,r.jsx)(e.p,{children:"Example 2:"}),"\n",(0,r.jsxs)(e.p,{children:['Input: s = "a", t = "a"',(0,r.jsx)(e.br,{}),"\n",'Output: "a"',(0,r.jsx)(e.br,{}),"\n","Explanation: The entire string s is the minimum window."]}),"\n",(0,r.jsx)(e.p,{children:"Example 3:"}),"\n",(0,r.jsxs)(e.p,{children:['Input: s = "a", t = "aa"',(0,r.jsx)(e.br,{}),"\n",'Output: ""',(0,r.jsx)(e.br,{}),"\n","Explanation: Both 'a's from t must be included in the window.",(0,r.jsx)(e.br,{}),"\n","Since the largest window of s only has one 'a', return empty string."]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.p,{children:"\u4f7f\u7528\u6ed1\u52a8\u7a97\u53e3\u6c42\u89e3\u3002\u4f7f\u7528\u4e00\u4e2a boolean \u6570\u7ec4\u6765\u8868\u793a\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u662f t \u4e2d\u7684\u5b57\u7b26\uff0c\u4f7f\u7528\u4e00\u4e2a int \u6570\u7ec4\u6765\u8868\u793a\u7a97\u53e3\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u8fd8\u5dee\u7684\u4e2a\u6570\u3002\u5411\u53f3\u79fb\u52a8\u7a97\u53e3\uff0c\u76f4\u5230\u6240\u6709 t \u4e2d\u7684\u5b57\u7b26\u7684\u6570\u91cf\u5728\u7a97\u53e3\u4e2d\u8db3\u591f\uff0c\u7136\u540e\u5c1d\u8bd5\u79fb\u52a8\u7a97\u53e3\u7684\u5de6\u8fb9\u7f29\u77ed\u7a97\u53e3\uff0c\u8bb0\u5f55\u7a97\u53e3\u957f\u5ea6\uff0c\u4e0d\u65ad\u91cd\u590d\u3002\u8fd4\u56de\u6700\u5c0f\u7684\u7a97\u53e3\u957f\u5ea6\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'public String minWindow(String s, String t) {\n    boolean[] need=new boolean[128];\n    int[] count=new int[128];\n    int num=0;\n    for(int i=0;i<t.length();++i){\n        char c=t.charAt(i);\n        if(!need[c]){\n            need[c]=true;\n            num++;\n        }    \n        count[c]++;\n    }\n    \n    int left=0, right=0;\n    int len=Integer.MAX_VALUE, start=0;\n    int valid=0;\n    while(right<s.length()){\n        char c=s.charAt(right);\n        right++;\n        \n        if(need[c]){\n            if(count[c]==1) valid++;\n            count[c]--;\n        }\n        \n        while(valid==num){\n            if(len>right-left){\n                len=right-left;\n                start=left;\n            }\n            \n            char d=s.charAt(left);\n            if(need[d]){\n                if(count[d]==0) {\n                    valid--;\n                }\n                count[d]++;\n            }\n            left++;\n        }\n    }\n    if(len==Integer.MAX_VALUE) return "";\n    return s.substring(start,start+len);\n}\n'})})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);