"use strict";(self.webpackChunkwjftu_ds=self.webpackChunkwjftu_ds||[]).push([[7697],{8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var r=t(6540);const i={},o=r.createContext(i);function l(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(o.Provider,{value:n},e.children)}},9062:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"algorithmPractice/leetcode/1305","title":"1305 All Elements in Two Binary Search Trees","description":"Leetcode","source":"@site/note/algorithmPractice/leetcode/1305.md","sourceDirName":"algorithmPractice/leetcode","slug":"/algorithmPractice/leetcode/1305","permalink":"/note/algorithmPractice/leetcode/1305","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1305,"frontMatter":{"sidebar_position":1305},"sidebar":"tutorialSidebar","previous":{"title":"1288 Remove Covered Intervals","permalink":"/note/algorithmPractice/leetcode/1128"},"next":{"title":"1359 Count All Valid Pickup and Delivery Options","permalink":"/note/algorithmPractice/leetcode/1359"}}');var i=t(4848),o=t(8453);const l={sidebar_position:1305},s="1305 All Elements in Two Binary Search Trees",a={},d=[];function c(e){const n={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"1305-all-elements-in-two-binary-search-trees",children:"1305 All Elements in Two Binary Search Trees"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/all-elements-in-two-binary-search-trees/",children:"Leetcode"})}),"\n",(0,i.jsx)(n.p,{children:"Given two binary search trees root1 and root2, return a list containing all the integers from both trees sorted in ascending order."}),"\n",(0,i.jsx)(n.p,{children:"\u5148\u901a\u8fc7\u524d\u5e8f\u904d\u5386\u628a\u6811\u8f6c\u6362\u4e3a\u94fe\u8868\uff0c\u7136\u540e\u5408\u5e76\u94fe\u8868\u3002\u4e0d\u786e\u5b9a\u8fd9\u6837\u505a\u662f\u6700\u597d\u7684\u65b9\u6cd5\uff0c\u53ef\u80fd\u8fd8\u6709\u66f4\u4f18\u7684\u89e3\u6cd5\u3002"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\n        LinkedList<Integer> l1 = new LinkedList<>();\n        LinkedList<Integer> l2 = new LinkedList<>();\n        \n        if(root1 != null) preOrder(root1, l1);\n        if(root2 != null) preOrder(root2, l2);\n        \n        List<Integer> ret = new LinkedList<>();\n        \n        while(l1.size()>0 && l2.size()>0){\n            if(l1.peek()<l2.peek()){\n                ret.add(l1.pop());\n            } else {\n                ret.add(l2.pop());\n            }\n        }\n        \n        if(l1.size()>0){\n            ret.addAll(l1);\n        } else {\n            ret.addAll(l2);\n        }\n        \n        return ret;\n    }\n    \n    private void preOrder(TreeNode node, List<Integer> list){\n        if(node.left!=null){\n            preOrder(node.left, list);\n        }\n        list.add(node.val);\n        if(node.right!=null){\n            preOrder(node.right, list);\n        }\n    }\n    \n    \n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);