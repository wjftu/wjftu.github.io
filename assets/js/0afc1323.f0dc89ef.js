"use strict";(self.webpackChunkwjftu_ds=self.webpackChunkwjftu_ds||[]).push([[2382],{497:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"algorithmPractice/leetcode/1202","title":"1202 Smallest String With Swaps","description":"Leetcode","source":"@site/note/algorithmPractice/leetcode/1202.md","sourceDirName":"algorithmPractice/leetcode","slug":"/algorithmPractice/leetcode/1202","permalink":"/note/algorithmPractice/leetcode/1202","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1202,"frontMatter":{"sidebar_position":1202},"sidebar":"tutorialSidebar","previous":{"title":"986 Interval List Intersections","permalink":"/note/algorithmPractice/leetcode/986"},"next":{"title":"1249 Minimum Remove to Make Valid Parentheses","permalink":"/note/algorithmPractice/leetcode/1249"}}');var r=i(4848),s=i(8453);const a={sidebar_position:1202},o="1202 Smallest String With Swaps",d={},l=[];function c(n){const e={a:"a",br:"br",code:"code",h1:"h1",header:"header",hr:"hr",p:"p",pre:"pre",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"1202-smallest-string-with-swaps",children:"1202 Smallest String With Swaps"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://leetcode.com/problems/smallest-string-with-swaps/",children:"Leetcode"})}),"\n",(0,r.jsx)(e.p,{children:"You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string."}),"\n",(0,r.jsx)(e.p,{children:"You can swap the characters at any pair of indices in the given pairs any number of times."}),"\n",(0,r.jsx)(e.p,{children:"Return the lexicographically smallest string that s can be changed to after using the swaps."}),"\n",(0,r.jsx)(e.p,{children:"Example 1:"}),"\n",(0,r.jsxs)(e.p,{children:['Input: s = "dcab", pairs = [[0,3],[1,2]]',(0,r.jsx)(e.br,{}),"\n",'Output: "bacd"',(0,r.jsx)(e.br,{}),"\n","Explaination:",(0,r.jsx)(e.br,{}),"\n",'Swap s[0] and s[3], s = "bcad"',(0,r.jsx)(e.br,{}),"\n",'Swap s[1] and s[2], s = "bacd"']}),"\n",(0,r.jsx)(e.p,{children:"Example 2:"}),"\n",(0,r.jsxs)(e.p,{children:['Input: s = "dcab", pairs = [[0,3],[1,2],[0,2]]',(0,r.jsx)(e.br,{}),"\n",'Output: "abcd"',(0,r.jsx)(e.br,{}),"\n","Explaination:",(0,r.jsx)(e.br,{}),"\n",'Swap s[0] and s[3], s = "bcad"',(0,r.jsx)(e.br,{}),"\n",'Swap s[0] and s[2], s = "acbd"',(0,r.jsx)(e.br,{}),"\n",'Swap s[1] and s[2], s = "abcd"']}),"\n",(0,r.jsx)(e.p,{children:"Example 3:"}),"\n",(0,r.jsxs)(e.p,{children:['Input: s = "cba", pairs = [[0,1],[1,2]]',(0,r.jsx)(e.br,{}),"\n",'Output: "abc"',(0,r.jsx)(e.br,{}),"\n","Explaination:",(0,r.jsx)(e.br,{}),"\n",'Swap s[0] and s[1], s = "bca"',(0,r.jsx)(e.br,{}),"\n",'Swap s[1] and s[2], s = "bac"',(0,r.jsx)(e.br,{}),"\n",'Swap s[0] and s[1], s = "abc"']}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.p,{children:"\u4f7f\u7528 union find \u7ed9\u4e0b\u6807\u5206\u7ec4\uff0c\u76f8\u540c\u7684\u7ec4\u538b\u5165\u5806\u4e2d\u8fdb\u884c\u6392\u5e8f\u3002union find \u9700\u8981\u5c06\u6bcf\u4e2a\u8282\u70b9\u5728 find \u7684\u65f6\u5019\u8fde\u63a5\u5230\u6839\u8282\u70b9\uff0c\u4e0d\u7136\u4f1a\u8d85\u65f6\u3002"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class Solution {\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\n        int len=s.length();\n        HashMap<Integer,PriorityQueue<Character>> map=new HashMap<>();\n        char[] arr=s.toCharArray();\n\n        //If unionFind[i]==i , i is a root node, or i is connected to unionFind[i]\n        //Try to group indexes to different groups\n        int[] unionFind=new int[len];\n        for(int i=0;i<len;++i){\n            unionFind[i]=i;\n        }\n        for(List<Integer> list:pairs){\n            int i1=list.get(0);\n            int i2=list.get(1);\n            //connect 2 groups to 1\n            union(unionFind, i1, i2);\n        }\n        for(int i=0;i<len;++i){\n            //each index is connected to a root id\n            int id=find(unionFind,i);\n            //each id has a priority queue\n            map.computeIfAbsent(id, key->new PriorityQueue<>()).add(arr[i]);\n        }\n        \n        for(int i=0;i<len;++i){\n            int id=find(unionFind,i);\n            arr[i]=map.get(id).poll();\n        }\n        \n        return String.valueOf(arr);\n    }\n    \n    /*\n    This function is able to find the root but cause time limit exceeded\n    private int find(int[] uf, int index){\n        while(uf[index]!=index) index=uf[index];\n        return index;\n    }\n    */\n    \n    private int find(int[] uf, int index){\n        int i=uf[index];\n        if(index==i) return index;\n        // set all node connected to root \n        uf[index]=find(uf, i);\n        return uf[index];\n    }\n    \n    //quick-union\n    private void union(int[] uf, int u, int v){\n        int uRoot=find(uf, u);\n        int vRoot=find(uf, v);\n        uf[uRoot]=vRoot;\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"\u6700\u5f00\u59cb\u4e0d\u4f1a union find \u7684\u65f6\u5019\u7684\u89e3\u6cd5\uff1a"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class Solution {\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\n        int len=s.length();\n        char[] arr=s.toCharArray();\n        ArrayList<TreeSet<Integer>> list=getAllSwaps(pairs,len);\n        for(TreeSet<Integer> set:list){\n            swap(arr,set);\n        }\n        return String.valueOf(arr);\n    }\n    \n\n    \n    private ArrayList<TreeSet<Integer>> getAllSwaps(List<List<Integer>> pairs, int len){\n        ArrayList<Integer>[] lists=new ArrayList[len];\n        for(int i=0;i<len;++i) lists[i]=new ArrayList<>();\n        for(List<Integer> l:pairs){\n            Integer i1=l.get(0);\n            Integer i2=l.get(1);\n            \n            lists[i1].add(i2);\n            lists[i2].add(i1);\n\n        }\n        boolean[] visited=new boolean[len];\n        ArrayList<TreeSet<Integer>> ret=new ArrayList<>();\n        for(int i=0;i<len;++i){\n            if(!visited[i] && lists[i].size()>0){\n                TreeSet<Integer> set=new TreeSet<>();\n                ret.add(set);\n                recur(set, i, visited, lists);\n            }\n        }\n        return ret;\n    }\n    \n    private void recur(Set<Integer> set, int index, boolean[] visited, \n                       ArrayList<Integer>[] lists){\n        visited[index]=true;\n        ArrayList<Integer> list=lists[index];\n        for(Integer i:list){\n            set.add(i);\n            if(!visited[i]){\n                recur(set,i,visited,lists);\n            }\n        }\n    }\n    \n    private void swap(char[] arr, TreeSet<Integer> set){\n        char[] toSwap=new char[set.size()];\n        int index=0;\n        for(Integer i:set){\n            toSwap[index++]=arr[i];\n        }\n        Arrays.sort(toSwap);\n        index=0;\n        for(Integer i:set){\n            arr[i]=toSwap[index++];\n        }\n    }\n\n}\n"})})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>o});var t=i(6540);const r={},s=t.createContext(r);function a(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);