"use strict";(self.webpackChunkwjftu_ds=self.webpackChunkwjftu_ds||[]).push([[7503],{710:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"algorithmPractice/leetcode/391","title":"391 Perfect Rectangle","description":"Leetcode","source":"@site/note/algorithmPractice/leetcode/391.md","sourceDirName":"algorithmPractice/leetcode","slug":"/algorithmPractice/leetcode/391","permalink":"/note/algorithmPractice/leetcode/391","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":391,"frontMatter":{"sidebar_position":391},"sidebar":"tutorialSidebar","previous":{"title":"389 Find the Difference","permalink":"/note/algorithmPractice/leetcode/389"},"next":{"title":"403 Frog Jump","permalink":"/note/algorithmPractice/leetcode/403"}}');var a=t(4848),i=t(8453);const o={sidebar_position:391},l="391 Perfect Rectangle",s={},c=[];function m(e){const n={a:"a",br:"br",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"391-perfect-rectangle",children:"391 Perfect Rectangle"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/perfect-rectangle/",children:"Leetcode"})}),"\n",(0,a.jsx)(n.p,{children:"Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi)."}),"\n",(0,a.jsx)(n.p,{children:"Return true if all the rectangles together form an exact cover of a rectangular region."}),"\n",(0,a.jsx)(n.p,{children:"Example 1:"}),"\n",(0,a.jsxs)(n.p,{children:["Input: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]",(0,a.jsx)(n.br,{}),"\n","Output: true",(0,a.jsx)(n.br,{}),"\n","Explanation: All 5 rectangles together form an exact cover of a rectangular region."]}),"\n",(0,a.jsx)(n.p,{children:"Example 2:"}),"\n",(0,a.jsxs)(n.p,{children:["Input: rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]",(0,a.jsx)(n.br,{}),"\n","Output: false",(0,a.jsx)(n.br,{}),"\n","Explanation: Because there is a gap between the two rectangular regions."]}),"\n",(0,a.jsx)(n.p,{children:"Example 3:"}),"\n",(0,a.jsxs)(n.p,{children:["Input: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]",(0,a.jsx)(n.br,{}),"\n","Output: false",(0,a.jsx)(n.br,{}),"\n","Explanation: Because two of the rectangles overlap with each other."]}),"\n",(0,a.jsx)(n.p,{children:"\u627e\u5230\u4e0a\u4e0b\u5de6\u53f3\u8fb9\u754c\uff0c\u6c42\u51fa\u5927\u77e9\u5f62\u7684\u9762\u79ef\uff0c\u5e76\u6c42\u6240\u6709\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\uff0c\u5982\u679c\u4e0d\u76f8\u7b49\uff0c\u5219\u65e0\u6cd5\u62fc\u6210\u3002\u7edf\u8ba1\u6240\u6709\u77e9\u5f62\u7684\u9876\u70b9\u6240\u5728\u7684\u70b9\u3002\u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a 1 \uff0c\u53ea\u80fd\u662f\u5927\u77e9\u5f62\u7684\u9876\u70b9\uff0c\u6b21\u6570\u4e3a 2 \uff0c\u4e0d\u80fd\u662f\u5927\u77e9\u5f62\u5b9a\u70b9\uff0c\u6b21\u6570\u4e3a 4 \uff0c\u4e0d\u80fd\u5728\u5927\u77e9\u5f62\u8fb9\u4e0a\u3002\u5982\u679c\u9762\u79ef\u6ca1\u6709\u95ee\u9898\uff0c\u6ee1\u8db3\u8fd9\u4e9b\u6761\u4ef6\u5373\u53ef\u62fc\u6210\u5927\u77e9\u5f62\u3002"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'class Solution {\n    int minX, minY, maxX, maxY;\n    long area;\n    public boolean isRectangleCover(int[][] rectangles) {\n        HashMap<Dot,Integer> map=new HashMap<>();\n        edgeAndArea(rectangles);\n        if(area!=(maxX-minX)*(maxY-minY))\n            return false;\n        int t;\n        for(int [] ret: rectangles){\n\n            Dot[] dots=new Dot[]{new Dot(ret[0],ret[1]),\n                    new Dot(ret[0],ret[3]),\n                    new Dot(ret[2],ret[1]),\n                    new Dot(ret[2],ret[3])\n            };\n            for(Dot dot:dots){\n                if(map.containsKey(dot)){\n                    t=map.get(dot);\n                    if(t>4)\n                        return false;\n                    map.put(dot,t+1);\n                } else {\n                    map.put(dot,1);\n                }\n            }\n\n\n        }\n        for(Map.Entry<Dot,Integer> set:map.entrySet()){\n            int val=set.getValue();\n            Dot d=set.getKey();\n            if(val==1 && (d.x==minX || d.x==maxX) && (d.y==minY || d.y==maxY)) continue;\n            else if(val==2 && ((d.x!=minX && d.x!=maxX) || (d.y!=minY && d.y!=maxY))) continue;\n            else if(val==4 && (d.x!=minX && d.y!=minY && d.x!=maxX && d.y!=maxY)) continue;\n            else return false;\n        }\n        return true;\n\n    }\n\n    private void edgeAndArea(int[][] rectangles){\n        area=0L;\n        minX=Integer.MAX_VALUE;\n        minY=Integer.MAX_VALUE;\n        maxX=Integer.MIN_VALUE;\n        maxY=Integer.MIN_VALUE;\n        for(int[] arr: rectangles){\n            if(arr[0]<minX) minX=arr[0];\n            if(arr[1]<minY) minY=arr[1];\n            if(arr[2]>maxX) maxX=arr[2];\n            if(arr[3]>maxY) maxY=arr[3];\n            area+=(arr[3]-arr[1])*(arr[2]-arr[0]);\n        }\n    }\n\n    private static class Dot{\n        int x;\n        int y;\n        public Dot(int x, int y){\n            this.x=x; this.y=y;\n        }\n        @Override\n        public boolean equals(Object d2){\n            if(!(d2 instanceof Dot)) return false;\n            Dot d=(Dot)d2;\n            if(x==d.x && y==d.y) return true;\n            return false;\n        }\n        @Override\n        public int hashCode(){\n            return x*7+y;\n        }\n        public String toString(){\n            return "x:"+x+" y:"+y;\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"\u65b9\u6cd5\u4e8c\uff1a"}),"\n",(0,a.jsx)(n.p,{children:"\u5b9a\u4e49\u4e00\u4e2a boolean \u6570\u7ec4\uff0c\u7edf\u8ba1\u662f\u5426\u88ab\u8986\u76d6\u3002\u8fd9\u79cd\u65b9\u6cd5\u6570\u636e\u91cf\u5927\u4f1a\u5185\u5b58\u4e0d\u591f\u3002\u3002\u3002"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"class Solution {\n    int minX, minY, maxX, maxY;\n    public boolean isRectangleCover(int[][] rectangles) {\n        if(rectangles==null || rectangles.length==0) return false;\n        edge(rectangles);\n        boolean[][] map=new boolean[maxX-minX][maxY-minY];\n        for(int[] ret:rectangles){\n            if(!fill(map, ret)) return false;\n        }\n        for(int i=0;i<map.length;++i){\n            for(int j=0;j<map[0].length;++j){\n                if(!map[i][j]) return false;\n            }\n        }\n        return true;\n        \n    }\n    \n    private void edge(int[][] rectangles){\n        minX=Integer.MAX_VALUE;\n        minY=Integer.MAX_VALUE;\n        maxX=Integer.MIN_VALUE;\n        maxY=Integer.MIN_VALUE;\n        for(int[] arr: rectangles){\n            if(arr[0]<minX) minX=arr[0];\n            if(arr[1]<minY) minY=arr[1];\n            if(arr[2]>maxX) maxX=arr[2];\n            if(arr[3]>maxY) maxY=arr[3];\n        }\n    }\n    \n    boolean fill(boolean[][] map, int[] ret){\n        int x,y;\n        for(int i=ret[0];i<ret[2];++i){\n            for(int j=ret[1];j<ret[3];++j){\n                x=i-minX;\n                y=j-minY;\n                if(map[x][y]) return false;\n                map[x][y]=true;\n            }\n        }\n        return true;\n    }\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var r=t(6540);const a={},i=r.createContext(a);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);